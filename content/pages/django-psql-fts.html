<h1>Full Text Search in PostgreSQL is Good Enough</h3>

Searching text is non-trivial, but for most use cases we can get 80% of the way there with a little Django + PostgreSQL magic. Our goal is to enable accurate and fast full text searching without setting up any new packages/databases/services/headaches besides our existing Django (2.x) project with an existing PostgreSQL (>=9.6) database.

<br/><br/>

We're going to design a simple blog. First, a model:

<pre>
    <code class="prettyprint lang-py">
        from django.db import models

        class Blog(models.Model):

            title = models.TextField()
            text = models.TextField()
    </code>
</pre>

Each blog post is stored in our Blog model with its title and text. Likely, you've already got a model with some text fields like the Blog model above. We're going to do a few things now:

<ul>
    <li>Add fields to store vectorized versions of title and text</li>
    <li>Enable indexing on our vectorized fields</li>
    <li>Generate a new migration file</li>
    <li>and add a trigger to automatically populate our vector fields</li>
</ul>

<h2>Add Vector Fields</h2>

We're going to keep our title and text vectors separate to enable searching through one or both of the fields. It is also possible to vectorize multiple fields into one vector field if you know you're only ever going to search through everything.

<br/><br/>

Our new model looks like this:

<pre>
    <code class="prettyprint lang-py">
        from django.contrib.postgres.search import SearchVectorField
        from django.db import models

        class Blog(models.Model):

            title = models.TextField()
            text = models.TextField()

            title_vector = SearchVectorField(null=True)
            text_vector = SearchVectorField(null=True)
    </code>
</pre>

You will note the "<code class="prettyprint lang-py">null=True</code>" kwarg passed into <code class="prettyprint lang-py">SearchVectorField</code>. We need to populate the vectors <i>after</i> their source fields have data in them, so we cannot create the vectors until after a Blog instance is saved. We will be adding a trigger later to automatically populate the vector fields, but first we need to set up a few more things.

<h2>Enable indexing on vector fields</h2>

We have two options for vector indexes in Postgres: <b>GIN</b> and <b>GiST</b>. It's worth reading <a href="https://www.postgresql.org/docs/current/static/textsearch-indexes.html">The Documentation</a> on the differences, but we're just going to go ahead and use <b>GIN</b> and not worry too much about the details.

<br/><br/>

Adding indexing to our vector fields is straightforward:

<pre>
    <code class="prettyprint lang-py">
        from django.contrib.postgres.indexes import GinIndex
        from django.contrib.postgres.search import SearchVectorField
        from django.db import models

        class Blog(models.Model):

            title = models.TextField()
            text = models.TextField()

            title_vector = SearchVectorField(null=True)
            text_vector = SearchVectorField(null=True)

            class Meta:
                indexes = [GinIndex(fields=[
                    'text_vector',
                    'title_vector',
                ])]
    </code>
</pre>

With the GinIndex in place, we have everything setup on the model that we will need, but we still need to reflect these changes in our database.

<h2>Generate a New Migration</h2>

